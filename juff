# Customizable constants
# For users:
export Default_inbox="${HOME}/Inbox_JuFF"
export GPG_program="gpg"
export GPG_keybox_ext=".kbx"
# For deployer:
export Debug_mode="on"
export Version="beta"
export URL_remote=
export Key_remote=
export Code_remote=

###############################################################################
error_exit(){
  local error_msg="${1:-"Unknown error"}"
  printf "%s\n" "${error_msg}"
  exit 1
} >&2

abs_path(){
# Transforms any path, including windows paths, to absolute path. Expands ~ too
# Exitcode: 0 (output to stdout) if path exists, 1 (outout to stderr) otherwise
  local path="${1}"
# Windows to Unix path [if operand is Unix path then wslpath outputs to stderr]
  local buffer=$(wslpath -u "${path}" 2>/dev/null); path="${buffer:-"${path}"}"
  path="${path//\\/}"  # Remove backslash, if any
  path="${path//\~/"${HOME}"}"  # Tilde expansion: ~
  path="${path//\~-/"${OLDPWD}"}"  # Tilde expansion: ~-
  [[ "${path}" != /* ]] && path="${PWD}/${path}"
  [[ -e "${path}" ]] && echo "${path}" && return 0
  echo "${path}" >&2 && return 1 
}

export Downloads="${Inbox}/Downloads"
export Chats="${Inbox}/Chats"
export Cache="${HOME}/.JuFF.cache"
export TMPDIR="${Cache}/tmp"

export Locks="${Cache}/locks"
export Encrypt_payload_lock="${Locks}/encrypt_payload.lock"
export Encrypt_card_lock="${Locks}/encrypt_card.lock"
export UL_lock="${Locks}/upload.lock"
export Chat_lock="${Locks}/chat.lock"

export Ref_stack="${Cache}/ref.repo.stack"
export URL_repo="${Ref_stack}/url"
export Key_repo="${Ref_stack}/key"
export Code_repo="${Ref_stack}/code"

export Get_stack="${Cache}/get.stack"
export Get_GPGHOME="${Get_stack}/gpghome.get"
export DL_queue="${Get_stack}/download.queue"
export Decrypt_queue="${Get_stack}/decrypt.queue"
export DL_GPGHOME="${Get_stack}/gpghome.dl"
export DL_silo="${Get_stack}/downloaded.silo"

export Post_stack="${Cache}/post.stack"
export UL_GPGHOME="${Post_stack}/gpghome.ul"
export Encrypt_queue="${Post_stack}/encrypt.queue"
export UL_queue="${Post_stack}/upload.queue"
export Post_queue="{Post_stack}/post.queue"
export Post_GPGHOME="${Post_stack}/gpghome.post"

export Logs="${Cache}/logs"
export UL_status="${Logs}/upload.log"
export DL_status="${Logs}/download.log"
export Post_status="${Logs}/post.log"
export Get_status="${Logs}/get.log"
export Encrypt_status="${Logs}/encrypt.log"
export Decrypt_status="${Logs}/decrypt.log"

# Username<email> can't contain ?,* etc. since git branchname can't have them
# Screen usernames for non-permissible characters: [[ =~^[a-z0-9A-Z_.#@]*$ ]]
export Self=

export Self_keyid=
export Self_keyring=
export GPG_passphrase_file=
alias gpg="${GPG_program} --batch --no-tty --quiet --no-greeting \
                      --armor --always-trust --no-auto-check-trustdb"
#For pubkey import and list-key. Add --no-default-keyring for secret key import
alias gpg-key='gpg --keyring "${Self_keyring}"'
#For everything requiring passphrase - sign, decrypt
alias gpg-pass='gpg-key --passphrase-file "${GPG_passphrase_file}" \
                                            --pinentry-mode loopback'

retrieve_pubkey(){
# Takes an accountname as argument. Pulls the respective branch in Key_remote
  local owner="${1}"
  local dir="${Post_stack}/${owner}/key"  # Shallow cloned when Chat_lock is set
  cd "${dir}"
  git pull --ff-only --quiet "${Key_remote}" "${owner}"
}>>"${Encrypt_status}"

push(){
# Takes an accountname as argument. Pushes to respective branch in URL_remote
  local owner="${1}"
  local dir="${Post_stack}/${owner}/url"  # Shallow cloned when Chat_lock is set
  local lock="${Locks}/${owner}.lock"
# Critical section begins. See examples in: man flock
(
  flock --wait 0.1 200 || exit
  cd "${dir}"
  git add --all 
  while ! git diff --quiet HEAD ; do
    git commit --quiet -m "${Self}"
    until git push --quiet "${URL_remote}"; do
      # The following may be seen as a shallow version of: git pull --rebase
      git fetch --quiet --depth=1 "${URL_remote}" "${owner}"
      git rebase --quiet FETCH_HEAD
    done
    git add --all
  done
)200>"${lock}"
}>>"${Post_status}"

encrypt_card(){
  local lock="${Encrypt_card_lock}"
# Critical section begins. See examples in: man flock
(
  flock --wait 0.1 200 || exit
  export GNUPGHOME="${Post_GPGHOME}"
  cd "${Post_queue}"
  local filename
  local cache="$(mktemp "${TMPDIR/XXXXX}")"
  while [[ -n "$(ls -A "${Post_queue}")" ]]; do
  for filename in *; do
      local to="${filename%%>*}>"
      local buffer="${filename#*>}" && buffer="${buffer#*.}"
      local ext=".${buffer%>*}"
      local cargoname="${buffer#*>}"
      case "${ext}" in
        .txt|.file)
          # These files now contain the download url only
          # Lets append the filename below the url: access with tail -1
          # This is to be done before encryption
          if [[ "${ext}"==.file ]]; then 
            printf "%s\n" "${cargoname// /\\}" >> "${filename}"
          fi
          retrieve_pubkey "${to}"
          gpg-pass --recipient "${to}" --sign --user "${Self_keyid}" \
              --output "${cache}" "${filename}"
          rm "${GNUPGHOME}/*${GPG_keybox_ext}"    
          ;;
        .key|.otp)
          mv "${filename}" "${cache}"
          ;;
        *)
          # These are files to be stored as is in key-repo user's branch
          # Hence they must be verified for user authentication
          # The first/last line of each file contains the filename
          # Server accesses the first(last) line with read < or head(tail) -1
          # gpg armored files remain uncorrupted if extra text is appended
          gpg-pass --sign --user "${Self_keyid}" \
              --output "${cache}" "${filename}"
          printf "%s\n" "${cargoname// /\\}" >> "${cache}"
          ;;        
      esac
      mv "${cache}" "${Post_stack}/${to}/${Self}${ext}"
      rm "${filename}"
      push "${to}" &
    done
  done
)200>"${lock}"
}>>"${Encrypt_status}"

upload(){
}>>"${UL_status}"

encrypt_payload(){
  local lock="${Encrypt_payload_lock}"
# Critical section begins. See examples in: man flock
(
  flock --wait 0.1 200 || exit
  export GNUPGHOME="${UL_GPGHOME}"
  cd "${Encrypt_queue}"
  local filename
  local cache="$(mktemp "${TMPDIR/XXXXX}")"
  while [[ -n "$(ls -A "${Encrypt_queue}")" ]]; do
  for filename in *; do
      local to="${filename%%>*}>"
      retrieve_pubkey "${to}"
      gpg-pass --recipient "${to}" --sign --user "${Self_keyid}" \
          --output "${cache}" "${filename}"
      rm "${GNUPGHOME}/*${GPG_keybox_ext}"    
      mv "${cache}" "${UL_queue}/${filename}"
      rm "${filename}"
      upload &
    done
  done
)200>"${lock}"
}>>"${Encrypt_status}"

post(){
# Parameters: recipient, payload, extension(.file|.txt|.otp|.key|.store)
# Posts payload to the proper encrypt queue
# Launches the daemon encrypt_payload or encrypt_card if not running already
  local to="${1}"
  local payload="${2}"
  local ext="${3}"
  local filename="${to}${EPOCHSECONDS}${ext}"
  case "${ext}" in
    .txt|.file)
      if [[ "${ext}"==.file ]]; then 
        ln "${payload}" "${Encrypt_queue}/${filename}>${payload##*/}"
      else
        mv "${payload}" "${Encrypt_queue}/${filename}"
      fi
      encrypt_payload &
      return
      ;;
    .otp)
      touch "${Post_queue}/${filename}"
      ;;
    .key)
      mv "${payload}" "${Post_queue}/${filename}"
      ;;
    *)
      mv "${payload}" "${Post_queue}/${filename}>${payload##*/}"
      ;;
  esac
      encrypt_card &
}

